* P.30 goの実行可能ファイルはELFフォーマット(Linuxで一般的なフォーマット)ではなく、独自のフォーマットらしい
* P.38 フォルダに1つのパッケージ定義のみが原則
* P.39 "\_test.go"はパッケージをテストするためのファイルと認識される
* := の意味

* 組み込み関数: プログラミング言語であらかじめ使用できる関数

### 参照
* https://employment.en-japan.com/engineerhub/entry/2018/06/19/110000
* スターティングGo言語


---
* receiver https://go-tour-jp.appspot.com/methods/8
  * ポインタレシーバの使用理由
    1. メソッドがレシーバの指す変数を変更するため
    2. メソッドの呼び出しごとに変数のコピーを避けるため


* レシーバはメソッドを実行する構造体を決定するもの
  * しかし、Javaとは異なりメソッド、インスタンスがnullでもメソッドの実行は可能
    * どんな利点があるのか？
      * 利点: null(Goでは、nil)チェックをメソッド内に入れられる
        * Go言語でも、ただinterfaceの変数が宣言されただけでは,メソッド実行時にエラーを吐く
* interfaceはメソッドのシグニチャの集まり

* 空のインターフェース https://go-tour-jp.appspot.com/methods/14
  * 任意の型の値を保持できる
    * -> 未知の型を扱える

* スコープ: 頭文字が大文字であれば、他パッケージから参照可能
  * Javaでは、細かく指定できる

* １つの型で同じメソッド名を許さない

* 使用していないパッケージがある場合、コンパイルエラーを吐く
  * コンパイル時間を短くするため

* 実装時に、スタックとヒープを気にする必要がない  
  * コンパイル時に自動で判別する
  * 変数への参照が残っていれば、ヒープに残る
    * https://qiita.com/rookx/items/a1e3d057a0ed71424094

---
## Go言語の概要
* Google社によって開発された言語
* 2009年に発表された
* 現在はオープンソース形式で開発されている
* 関数型言語
* シンプル
  * 予約語が少ない　 = 25単語　(言語の仕様面)
  * 機能が安易に増やさない(言語の開発面)
  * 自動型変換をしない(動作面)
* 静的型付け言語
* ガーベジコレクションあり
* コンパイルにより1つのバイナリファイルになる
* C言語からの進化系
<!-- * イメージ: 現代に近づいたC言語 -->
<!-- * 研究するための言語ではなく、問題解決のための言語 -->


* マルチプラットフォームで動作
  * Go言語では、クロスコンパイルによって別のOSでも単一ソースコードから実行ファイルを生成可能である
  * Javaでは、JVMによってOSの違いを埋めていた
    * コンパイル後のファイルサイズ
      * 処理: 「Hello World!」を出力する
| 言語 | ファイルサイズ(B) |
| ---- | ----------------- |
| Java | 426               |
| Go   | 2,008,640         |

* 標準ツールが豊富

## Go言語の仕様
<!-- ### コンパイル言語 -->
---
### 制御構文
* 条件を書くための 「( )」 を書かない
#### 条件分岐
* if
  * 初期値を設定可能
* switch
  * breakを必要としない
  * breakをせずに下の処理も行いたいために throughout
  * 型ごとで分岐可能
  * 値で分岐可能
  * 条件式で分岐可能

#### 繰り返し処理
* while, do-whileは存在せず、for文のみが存在する
* 拡張for文の書き方が可能

---
### 関数型言語
* 関数と構造体によってプログラミングする
  * 関数: 手続きを定義するもの
  * 構造体: イメージはクラスの機能を減らしたもの
    * 構造体は、クラスでのメンバー変数を定義する
    * メソッド(= 構造体の振る舞い)を定義できる
      * メソッドは関数にレシーバーを定義したもの
---
### 関数の仕様
* 複数の戻り値を設定可能
* 変数に代入可能

---
### 継承
* Go言語には継承が存在しない
 * 構造体の階層構造を取ることはない
 * 使用するなら移譲

---
### インターフェース
* インターフェースは存在する
  * しかし、実装方法が特殊である
    * ソースコード: https://play.golang.org/p/w6_x9VINmrb
---
### エラー処理の方法
* エラー処理専用の機構はあるが、基本的に使用しない
  * ランタイムエラー用の組み込み関数: panic, recover
    *
  <!-- * 例: Javaでの try-catch-finaly構文 -->
* 基本は、複数の返し値の1つとして返す方法を取る

---
<!-- ### 変数や関数のスコープ
* 定義する場所と名称の頭文字により決まる
  * 頭文字が大文字の場合: 別パッケージから参照可能
  * 頭文字が小文字の場合: 定義されるブロック内でのみ参照可能 -->

---
### 配列への参照方法
* スライス
  * 配列の全部もしくは、全部を参照するための機能
  * 可変長配列
  * 要素: 型, 要素数, 容量
  * 注意点: スライスを対象として使用できる組み込み関数 append の仕様
    * 配列によって確保された範囲以上に要素を追加すると、要素のコピーが発生し、別のメモリが確保される

---
### 並行処理
* 並行処理と並列処理の違い
  * 例) カレーライスの作り方
* スレッドより軽量な goroutine を使用する

---
## ツール
* go fmt
  * フォーマットできる
    * コード規約を設定せずとも、「go fmtを実行したソースコード」とすれば、コードの書き方が統一される
* go test
  * テストツール
    * テストコードを実行する
      * 頭文字が「Test_」である関数を実行してテストする
    * カバレッジの計算を行う

---
## スライド
* qiita https://qiita.com/t-kusakabe/items/725e7438892bba395062
* github https://github.com/hakimel/reveal.js

---
## 情報
* slide https://www.slideshare.net/takuyaueda967/go-77689475
* goらしさ https://employment.en-japan.com/engineerhub/entry/2018/06/19/110000
* 読み直したいgo基礎 https://budougumi0617.github.io/2019/06/20/golangtokyo25-read-again-awesome-go-article/
* playground https://play.golang.org/
* Effective go http://go.shibu.jp/effective_go.html
* goつまづきポイント https://future-architect.github.io/articles/20190713/

---
* Go言語が作成された目的は？
  * 以下が求められると考えたため
    *
    * 並行性、並列性 理由: マルチコアCPUにより
      * 並行プログラムのリソース管理のために、ガベージコレクション等の自動メモリ管理が必要


* 基本原則
  * プログラミングの容易さ
  * コンパイルの速度
  * 概念の直行性
  * 並行性
  * ガベージコレクション

### オブジェクト指向言語
* カプセル化
* 継承
*


---
## 疑問
### 依存関係をなくすことによる恩恵は？
  * 継承により以下の問題点がある
    * 柔軟性がなくなる -> スーパークラスでのメソッド内の処理を変更することによる影響が大きい
  * Golangは継承ではなく、コンポジションによりオブジェクト間の関係を表す

### errorを返す関数を複数個実行することになった場合、その関数を実行するたびにif文で判断するのか？

### goroutineとスレッドの関係
* goroutine
  * CSP(Communicating Sequential Processes)の考えに基づいている
    * CSPがリソース管理をサポートすることについて最も成功したモデルの1つであるため
      * ソース: https://golang.org/doc/faq#goroutines
  * 1つのGoプログラムで複数のOSスレッドをスケジューリングする
    * m個のゴルーチンとn個のOSスレッドで他州化する(m:nスケジューリング)
    * OSカーネルによりOSスレッドはスケジュールされており、数ミリ秒ごとにスケジューラが呼び出される。スレッドのレジスタをメモリへ保存して、優先度が高いスレッドの実行を再開させる。
      * ソース: プログラミング言語Go P.324

### 例外がない理由
* 理由は２つ
  * 制御構造に入っているとコードが複雑になるため
  * 通常のエラーを例外で処理することが多い傾向があるため

* エラー処理のうまい方法 https://blog.golang.org/errors-are-values
